"""
This python module contains all the core-logic to generate
graphs by different algorithms. The algorithms are implemented
in the form of functions and each function takes a graph object
as an argument and returns a new graph object generated by the
algorithm. The algorithms implemented in this module are:
- Mesh randomd graph 
- Erdos-Renyi random graph
- Gilbert random graph
- Geographical random graph
- Barabasi-Albert varian graph
- Dorogovtsev-Mendes graph
"""
from models.graph import Graph, Node, Edge, GeoNode
from generators import utils
import random

def mesh_random_graph(m:int, n:int, is_directed: bool=False, graph_name: str="") -> Graph:
    """
    Generate a graph with ,m*n nodes and connect n+1 node and 
    m+1 node with an edge in a grid 
    :param m: number of columns
    :param n: number of rows
    :param is_directed: if the graph is directed
    :param graph_name: name of the graph
    """
    if m < 1 or n < 1:
        print("m and n must be bigger than 1")
        raise ValueError()

    if graph_name == "":
        graph_name = f"Mesh_{m}x{n}"

    graph = Graph(is_directed=is_directed, name=graph_name)
    list_of_nodes = list()    
    # Create list of nodes
    for column in range(m):
        row_nodes = list()
        for row in range(n):
            node_name = f"{column + 1}{row + 1}"
            node = Node(name=node_name)
            row_nodes.append(node)
        list_of_nodes.append(row_nodes)
    # print("List of nodes: ", list_of_nodes)
    # Flatten list of nodes

    for col in range(m):
        for ix in range(n):
            if ix + 1 < n:
                graph.add_edge(list_of_nodes[col][ix], list_of_nodes[col][ix + 1])
            if col + 1 < m:
                graph.add_edge(list_of_nodes[col][ix],list_of_nodes[col + 1][ix])

    # print("List of edges: ", list_of_edges)
    list_of_nodes = [node for row in list_of_nodes for node in row]
    graph.nodes = list_of_nodes

    graph.save_graphviz_by_node()
    return graph

def erdos_renyi_random_graph(n:int, m:int, is_directed: bool=False, graph_name: str="") -> Graph:
    """
    Generate a graph with n nodes and try m times 
    to create an edge between two nodes using the Erdos-Renyi model
    :param n: number of nodes
    :param m: number of tries to create an edge
    :param is_directed: if the graph is directed
    :param graph_name: name of the graph
    """
    # list_of_nodes = list()
    if graph_name == "":
        graph_name = f"Erdos_{m}x{n}"
    graph = Graph(is_directed=is_directed, name=graph_name)
    
    for i in range(n):
        graph.add_node(Node(name=str(i)))
    print(graph.get_nodes())
    # list_of_edges = list()
    
    while len(graph.edges) < m:
        selected_nodes = random.sample(graph.nodes, 2)
        print(selected_nodes)
        if selected_nodes[0] != selected_nodes[1]:
            graph.add_edge(selected_nodes[0], selected_nodes[1])
            
    
    
    # generated_graph = Graph(nodes=list_of_nodes,
    #                         edges=list_of_edges,
    #                         is_directed=is_directed,
    #                         name=graph_name)

    graph.save_graphviz_by_node()

    return graph

def gilbert_random_graph(n:int, p:float, is_directed: bool=False, graph_name: str="") -> Graph:
    """
    Generate a graph with n nodes and try m times 
    to create an edge between two nodes
    :param n: number of nodes
    :param p: probability of creating an edge
    """
    if graph_name == "":
        graph_name = f"Gilbert_{n}_{int(p*100)}"
    graph = Graph(is_directed=is_directed, name=graph_name)

    for i in range(n):
        graph.add_node(Node(name=str(i)))
        
    for i in range(n):
        for j in range(n):
            if random.random() < p and i != j:
                graph.add_edge(graph.nodes[i], graph.nodes[j])
    return graph


def geographical_random_graph(n:int, r:float, is_directed: bool=False, graph_name: str="") -> Graph:
    """
    Generate a graph with n nodes and connect two nodes if they are closer than r
    """
    if graph_name == "":
        graph_name = f"Geographical_{n}_{int(r*100)}"
        
    graph = Graph(is_directed=is_directed, name=graph_name)
    for i in range(n):
        graph.add_node(GeoNode(name=str(i), x_coord=random.random(), y_coord=random.random()))

    for i in range(n):
        for j in range(n):
            if i != j:
                distance = graph.nodes[i].calculate_distance(graph.nodes[j])
                if distance < r:
                    graph.add_edge(graph.nodes[i], graph.nodes[j])
                    
    graph.save_graphviz_by_node()
    return graph

def barabasi_albert_graph(n:int, d:int, is_directed: bool=False, name: str="") -> Graph:
    """
    Generate a graph with n nodes and m edges
    """
    if name == "":
        name = f"Barabasi-Albert_{n}_{d}"
    graph = Graph(is_directed=is_directed, name=name)

    for i in range(n):
        new_node = Node(name=str(i))
        graph.add_node(new_node)
        for existent_node in graph.nodes:
            if existent_node != new_node:
                chances =  1 - (existent_node.get_degree() / d)
                if chances > random.random():
                    graph.add_edge(new_node, existent_node)
            
    graph.save_graphviz_by_node()
    
    return graph
    
    
def dorogovtsev_mendes_graph(n:int, is_directed: bool=False, graph_name: str="") -> Graph:
    """
    Generate a graph with n nodes
    """
    if n < 1:
        print("n must be bigger than 1")
        raise ValueError()
    list_of_nodes = [Node(name=str(i)) for i in range(3)]
    list_of_edges = [Edge(list_of_nodes[0], list_of_nodes[1]),
                    Edge(list_of_nodes[1], list_of_nodes[2]),
                    Edge(list_of_nodes[2], list_of_nodes[0])]
    for i in range(3, n):
        list_of_nodes.append(Node(name=str(i)))
        random_edge = random.choice(list_of_edges)
        list_of_edges.append(Edge(list_of_nodes[i], random_edge.node_from))
        list_of_edges.append(Edge(list_of_nodes[i], random_edge.node_to))
    if graph_name == "":
        graph_name = f"Dorogovtsev_Mendes_{n}"
    graph = Graph(nodes=list_of_nodes,
                  edges=list_of_edges,
                  is_directed=is_directed,
                  name=graph_name)
    graph.save_graphviz(filename=graph_name)
    return graph


