"""
This python module contains all the core-logic to generate
graphs by different algorithms. The algorithms are implemented
in the form of functions and each function takes a graph object
as an argument and returns a new graph object generated by the
algorithm. The algorithms implemented in this module are:
- Mesh randomd graph 
- Erdos-Renyi random graph
- Gilbert random graph
- Geographical random graph
- Barabasi-Albert varian graph
- Dorogovtsev-Mendes graph
"""
from models.graph import Graph, Node, Edge, GeoNode
from generators import utils
import random

def mesh_random_graph(m:int, n:int, is_directed: bool=False, graph_name: str="") -> Graph:
    """
    Generate a graph with ,m*n nodes and connect n+1 node and 
    m+1 node with an edge in a grid 
    :param m: number of columns
    :param n: number of rows
    :param is_directed: if the graph is directed
    :param graph_name: name of the graph
    """
    if m < 1 or n < 1:
        print("m and n must be bigger than 1")
        raise ValueError()

    if graph_name == "":
        graph_name = f"Mesh_{m}x{n}"

    graph = Graph(is_directed=is_directed, name=graph_name)
    list_of_nodes = list()    
    # Create list of nodes
    for column in range(m):
        row_nodes = list()
        for row in range(n):
            node_name = f"{column + 1}{row + 1}"
            node = Node(name=node_name)
            row_nodes.append(node)
        list_of_nodes.append(row_nodes)
    # print("List of nodes: ", list_of_nodes)
    # Flatten list of nodes

    for col in range(m):
        for ix in range(n):
            if ix + 1 < n:
                graph.add_edge(list_of_nodes[col][ix], list_of_nodes[col][ix + 1])
            if col + 1 < m:
                graph.add_edge(list_of_nodes[col][ix],list_of_nodes[col + 1][ix])

    # print("List of edges: ", list_of_edges)
    list_of_nodes = [node for row in list_of_nodes for node in row]
    graph.nodes = list_of_nodes

    graph.save_graphviz_by_node()
    return graph

def erdos_renyi_random_graph(n:int, m:int, is_directed: bool=False, graph_name: str="") -> Graph:
    """
    Generate a graph with n nodes and try m times 
    to create an edge between two nodes using the Erdos-Renyi model
    :param n: number of nodes
    :param m: number of tries to create an edge
    :param is_directed: if the graph is directed
    :param graph_name: name of the graph
    """
    # list_of_nodes = list()
    if graph_name == "":
        graph_name = f"Erdos_{m}x{n}"
    graph = Graph(is_directed=is_directed, name=graph_name)
    
    for i in range(n):
        graph.add_node(Node(name=str(i)))
    print(graph.get_nodes())
    # list_of_edges = list()
    
    while len(graph.edges) < m:
        # Selesct a random sample of two nodes from the set of nodes
        selected_nodes = random.sample(list(graph.nodes), 2)
        print(selected_nodes)
        if selected_nodes[0] != selected_nodes[1]:
            graph.add_edge(selected_nodes[0], selected_nodes[1])

    graph.save_graphviz_by_node()

    return graph

def gilbert_random_graph(n:int, p:float, is_directed: bool=False, graph_name: str="") -> Graph:
    """
    Generate a graph with n nodes and try m times 
    to create an edge between two nodes
    :param n: number of nodes
    :param p: probability of creating an edge
    """
    if graph_name == "":
        graph_name = f"Gilbert_{n}_{int(p*100)}"
    graph = Graph(is_directed=is_directed, name=graph_name)

    for i in range(n):
        graph.add_node(Node(name=str(i)))
        
    for i in range(n):
        for j in range(n):
            if random.random() < p and i != j:
                graph.add_edge(graph.nodes[i], graph.nodes[j])
                
    graph.save_graphviz_by_node()
    return graph


def geographical_random_graph(n:int, r:float, is_directed: bool=False, graph_name: str="") -> Graph:
    """
    Generate a graph with n nodes and connect two nodes if they are closer than r
    """
    if graph_name == "":
        graph_name = f"Geographical_{n}_{int(r*100)}"
        
    graph = Graph(is_directed=is_directed, name=graph_name)
    for i in range(n):
        graph.add_node(GeoNode(name=str(i), x_coord=random.random(), y_coord=random.random()))

    for i in range(n):
        for j in range(n):
            if i != j:
                distance = graph.nodes[i].calculate_distance(graph.nodes[j])
                if distance < r:
                    graph.add_edge(graph.nodes[i], graph.nodes[j])
                    
    graph.save_graphviz_by_node()
    return graph

def barabasi_albert_graph(n:int, d:int, is_directed: bool=False, graph_name: str="") -> Graph:
    """
    Generate a graph with n nodes and m edges
    """
    if graph_name == "":
        graph_name = f"Barabasi-Albert_{n}_{d}"
    graph = Graph(is_directed=is_directed, name=graph_name)

    # Create initial graph with 5 nodes
    initial_nodes = list()
    for i in range(5):
        initial_nodes.append(Node(name=str(i)))
        
    for i in range(5):
        for j in range(5):
            if i != j:
                graph.add_edge(initial_nodes[i], initial_nodes[j])
    
    while len(graph.nodes) < n:
        new_node = Node(name=str(i + 5))
        current_nodes = graph.nodes.copy()
        for existent_node in current_nodes:
                # d is the max grade of the node and the chances of connecting to the node
                # is proportional to the grade of the node
                if existent_node.get_degree() < d and random.random() < existent_node.get_degree() / sum([node.get_degree() for node in current_nodes]):
                    graph.add_edge(new_node, existent_node)
        i += 1
    graph.save_graphviz_by_node()
    return graph
    
    
def dorogovtsev_mendes_graph(n:int, is_directed: bool=False, graph_name: str="") -> Graph:
    """
    Generate a graph with n nodes
    """
    if graph_name == "":
        graph_name = f"Dorogovtsev-Mendes_{n}"
        
    graph = Graph(is_directed=is_directed, name=graph_name)
   # Generate start 3 nodes and edges:
    for i in range(3):
        graph.add_node(Node(name=str(i)))

    graph.add_edge(graph.nodes[0], graph.nodes[1])
    graph.add_edge(graph.nodes[1], graph.nodes[2])
    graph.add_edge(graph.nodes[2], graph.nodes[0])

    for i in range(3, 3+n):
        new_node = Node(name=str(i))
        selected_edge = random.choice(graph.edges)
        graph.add_edge(new_node, selected_edge.node_from)
        graph.add_edge(new_node, selected_edge.node_to)
        graph.add_node(new_node)
        
    graph.save_graphviz_by_node()
    return graph
